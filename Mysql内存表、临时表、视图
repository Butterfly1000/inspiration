Mysql三种虚拟表:临时表、内存表、视图。
★临时表
临时表是建立在系统临时文件夹中的表。临时表的数据和表结构都存储在内存之中，退出的时候所占的空间会被释放。

1.创建临时表
create temporary table tmp_table(
    id int(11) not null auto_increment,
    name varchar(10) not null,
    value int(11) not null,
    primary key(id)
);

2.关键字为temporary

3.查看表结构
≥ 注意:
  show tables;
  show table status
  这两个命令"无法"查看临时表。 但是可以查内存表。

4.可以查看表建立sql语句
show create table tmp_table; (个人喜欢：show create table tmp_table\G;)

5.直接将查询结果导入临时表
CREATE TEMPORARY TABLE tmp_table SELECT * FROM table_name

6.设定临时表大小
tmp_table_size #临时表的容量

7.临时表的应用场景
当工作在十分大的表上运行时，运行相关查询，来获的一个大量数据的小的子集。较好的办法，不是对整个表运行这些查询，而是让MySQL每次找出所需的少数记录，
将记录选择到一个临时表，然后对这些表运行查询。
 a.一个sql语句关联两个表以上的时候，查询到的结果存放在临时表中。
 b.程序执行过程中可能需要存放一些临时的数据，这些数据在整个程序的会话过程中都需要用的等等
 c.临时表默认的是MyISAM,但是可以修改
 d.内部临时表，就是查询的时候，服务器会优化查询，使用内部临时表。比如 order by 的列不是表中的第一列。

show warnings 能查看优化查询的sql语句

8.临时表的注意事项
 a.临时表只在当前连接可见，当这个连接关闭的时候，会自动drop。比如打开mysql就是一个连接会话。两个不同的连接可以使用相同名字的临时表，两个表之间
   不存在什么关系，如果临时表的名字和已经存在的磁盘表名字一样，那么临时表会"暂时覆盖"磁盘表。就是说，你select 查询，只会显示临时表里面的，不会
   显示磁盘表。
 b.临时表的存储引擎：memor，myisam，merge，innodb
 c.临时表不支持，mysql cluster(集群)
 d.同一个查询语句，只能用一次临时表，就是说不能将表和自己做连接等。
 e.重命名表，不能用rename 可以用alter table代替
   RENAME TABLE tbl_name TO new_tbl_name[, tbl_name2 TO new_tbl_name2,...]   ×（错误，针对临时表）
   alter table old_name rename new_name   √（正确）
 f.如果超出了临时表的容量，临时表会转换成磁盘表（要特别注意，否则可能会莫名其妙方向磁盘空间不足了）

★内存表
简介：
内存表的表结构建立在磁盘里面，数据放在内存里面，当mysql重启之后，内存表的数据会丢失，表结构依旧存在，会执行一次truncate操作（截断表）。

1.内存表的建立
CREATE TEMPORARY TABLE tmp_table (
    id int(11) not null,
    name varchar(10) not null,
    value int(11) not null,
    primary key(id)
)  TYPE = HEAP  
#注意： TYPE = HEAP必须要有
#和临时表不同的地方在于，多了个type=heap（堆）

结果报1064错误！！！
原因：
使用MariaDB 创建表TYPE=HEAP 类型出现错误使用ENGINE=memory代替。
-------------------------------------
这边找了篇文章，原文链接https://blog.csdn.net/tianlianchao1982/article/details/7642031
MEMORY存储引擎用存在内存中的内容来创建表。这些在以前被认识为HEAP表。
MEMORY是一个首选的术语，虽然为向下兼容，HEAP依旧被支持。
每个MEMORY表和一个磁盘文件关联起来。文件名由表的名字开始，并且由一个.frm的扩展名来指明它存储的表定义。
要明确指出你想要一个MEMORY表，可使用ENGINE选项来指定：
CREATE TABLE t (i INT) ENGINE = MEMORY;

1.表受限于mysqld变量max_heap_table_size(默认16M)；
2.HEAP数据表从MySQL4.1开始才允许使用自增列；
3.ENGINE =Heap;从MySQL4.1后，首选 ENGINE =MEMORY;（重点！）
4.From MySQL 4.1 on, hash indexes are still the default, but you can specify explicitly that a MEMORY table index should be a HASH or 
  BTREE；
5.与许多其他散列表不同，Heap表允许非惟一的键；
6.Memory表使用固定长度行的格式存储；
7.不支持BLOB或TEXT列；
8.除了max_heap_table_size限制和计算机的内存限制以外，可以在有些安装上达到每个表4GB的限制，因为这个限制是由32位计算机的地址空间强加的。
9.如果你正使用复制，当主服务器被关闭且重启动之时，主服务器的MEMORY表变空。可是从服务器意识不到这些表已经变空，所以如果你从它们选择数据， 
  它就返回过时的内容。自从服务器启动后，当一个MEMORY表在主服务器上第一次被使用之时，一个DELETE FROM语句被自动写进主服务器的二进制日志，
  因此再次让从服务器与主服务器同步。注意：即使使用这个策略，在主服务器的重启和它第一次使用该表之间的间隔中，从服务器仍旧在表中有过时数据。
  可是，如果你使用--init-file选项于主服务器启动之时在其上推行MEMORY表。它确保这个时间间隔为零。（可以研究一下）
-------------------------------------
更新创建方法：
CREATE TABLE tmp_table (
    id int(11) not null auto_increment,
    name varchar(10) not null,
    value int(11) not null,
    primary key(id)
) ENGINE=MEMORY

2.使用场景及注意事项
使用场景：
  a.内存表使用hash索引把数据保存在内存中，具有更快的速度，可以用来缓存。适合缓存中小型数据库（数据存在内存，大型容易吃不消）
  b.内存表的默认引擎是memory
注意: 
  a.内存表不支持BLOB或TEXT类型;（已验证）
  b.内存表对所有的用户连接都是可用的。这就意味着，多个会话连接的内存表名字不能重复，具有唯一性;(已验证)
  c.内存表如果复制数据进去的话，所有的原有格式都不会存在，需要重新设置;复制之后所有主键、索引、自增等格式将不复存在，需要重新添加主键和索引。
  d.重启造成数据丢失，可以drop表之后重新复制数据等。一定有更好的方法（参照上面）;
  e.内存表不支持事务，而且是表锁，当修改频繁时，性能会下降;
  f.支持简单的操作符>=<这三个，
  （可能还有其他和版本有一定关系的注意点，但我使用的是>5.5.0的版本，未发现问题，就不贴了）
缺点：  
  a.不好的地方的话，应该在于数据了，因为数据都在内存里，要注意防止丢失；
 

★总结
内存表和临时表的主要区别：
1.存储
内存表 表结构存储在磁盘中，数据存储在内存中
临时表 表结构和数据都存储在内存中

2.会话
内存表 是可以多个会话共享的
临时表 是单个会话独享的，是会话级别的

3.引擎
内存表默认，memory
临时表默认，myisam

4.断开连接
临时表 啥都不剩
内存表 只剩下表结构

5.性能
内存表由于所有的内容都是放在内存中，所以相对来说，速度较快但是同时数据的维护较为困难

★视图

原文链接：https://blog.csdn.net/qq_41376740/java/article/details/79393943
